#
# This file is part of the cry package
#

# Functions connected to reflections data.
# Useful S3-type functions for handy use outside the main S4 framework


#' Load an XDS_ASCII file's header.
#'
#' This function reads information from the header of an
#' XDS_ASCII.HKL data file and organises it into a named list
#' with a variable number of components, according to the type
#' of XDS_ASCII.HKL file (see details in
#' \code{\link{readXDS_ASCII}}).
#'
#' @param filename A character string. The path to a valid
#'                 XDS ASCII file.
#' @return A named list. Each name correspond to a valid field in
#'         the xds header.
#'
#' @examples
#'
#' # Load one of the XDS ASCII files included with
#' # this distribution of cry
#' datadir <- system.file("extdata",package="cry")
#' filename <- file.path(datadir,"xds_ascii_01.hkl")
#' ltmp <- readXDS_ASCII_Header(filename)
#' print(names(ltmp))
#'
#' @export
readXDS_ASCII_Header <- function(filename) {
  # Open file connection
  ff <- file(filename)

  # Read in all lines
  lXDS <- readLines(ff,warn=FALSE)

  # Select lines starting with '!'
  tmp <- substr(lXDS,1,1)
  idx <- which(tmp == "!")
  lXDS <- lXDS[idx]

  # Close connection
  close(ff)

  # Is it an XDS ASCII?
  idx <- grep("FORMAT=XDS_ASCII",lXDS)
  if (length(idx) != 1) {
    msg <- "Not a valid XDS ASCII file.\n"
    cat(msg)

    return(NULL)
  }

  # Final list (this function only fills first two fields)
  outlist <- list(processing_info=list(),header=list(),
                  reflections=list())

  ### processing_info section ###

  # Merge
  idx <- grep("MERGE",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx],"  ")[[1]]
    jdx <- grep("MERGE",stmp)
    ltmp <- strsplit(stmp[jdx],"=")
    stmp <- trimws(ltmp[[1]][2],"both")
    outlist$processing_info$MERGE <- as.logical(stmp)
  } else {
    outlist$processing_info$MERGE <- NULL
  }
  # Friedel
  idx <- grep("FRIEDEL",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx],"  ")[[1]]
    jdx <- grep("FRIEDEL",stmp)
    ltmp <- strsplit(stmp[jdx],"=")
    stmp <- trimws(ltmp[[1]][2],"both")
    outlist$processing_info$FRIEDEL <- as.logical(stmp)
  } else {
    outlist$processing_info$FRIEDEL <- NULL
  }

  # Profile fitting
  idx <- grep("PROFILE_FITTING",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx],"=")
    stmp <- trimws(stmp[[1]][2],"both")
    outlist$processing_info$PROFILE_FITTING <- as.logical(stmp)
  } else {
    outlist$processing_info$PROFILE_FITTING <- NULL
  }

  ### header section ###

  # Name of images' template
  idx <- grep("NAME_TEMPLATE_OF_DATA_FRAMES",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx],"=")
    stmp <- strsplit(stmp[[1]][2]," ")
    T1 <- trimws(stmp[[1]][1],"both")
    T2 <- trimws(stmp[[1]][2],"both")
    Tlist <- list(NAME=T1,TYPE=T2)
    outlist$header$NAME_TEMPLATE_OF_DATA_FRAMES <- Tlist
  } else {
    outlist$header$NAME_TEMPLATE_OF_DATA_FRAMES <- NULL
  }

  # Generated by
  idx <- grep("Generated",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx],"by")
    stmp <- trimws(stmp[[1]][2],"both")
    outlist$header$GENERATED_BY <- stmp
  } else {
    outlist$header$GENERATED_BY <- NULL
  }

  # Input files list (XSCALE) (ISET)
  idx <- grep("COMPRISES",lXDS)
  if (length(idx) != 0) {
    nll <- 0
    iflag <- TRUE
    iset <- c()
    while(iflag) {
      nll <- nll+1
      jdx <- grep("ISET",lXDS[idx+nll])
      if (length(jdx) == 1) {
        stmp <- strsplit(lXDS[idx+nll],"ISET=")[[1]][2]
        iset <- c(iset,trimws(stmp,"both"))
      } else {
        iflag <- FALSE
      }
    }
    outlist$header$ISET <- iset
  } else {
    outlist$header$ISET <- NULL
  }

  # Date
  idx <- grep("DATE",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx],"=")
    stmp <- trimws(stmp[[1]][length(stmp[[1]])],"both")
    outlist$header$DATE <- stmp
  } else {
    outlist$header$DATE <- NULL
  }

  # Data range
  idx <- grep("DATA_RANGE",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx],"=")[[1]][2]
    stmp <- strsplit(stmp," ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    outlist$header$DATA_RANGE <- c(as.numeric(stmp[jdx[1]]),
                                   as.numeric(stmp[jdx[2]]))
  } else {
    outlist$header$DATA_RANGE <- NULL
  }

  # Rotation axis
  idx <- grep("ROTATION_AXIS",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx]," ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    tmp <- c()
    for (i in 2:length(jdx)) {
      tmp <- c(tmp,as.numeric(stmp[jdx[i]]))
    }
    outlist$header$ROTATION_AXIS <- tmp
  } else {
    outlist$header$ROTATION_AXIS <- NULL
  }

  # Oscillation range
  idx <- grep("OSCILLATION_RANGE",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx]," ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    outlist$header$OSCILLATION_RANGE <- as.numeric(stmp[jdx[2]])
  } else {
    outlist$header$OSCILLATION_RANGE <- NULL
  }

  # Starting angle
  idx <- grep("STARTING_ANGLE",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx],"  ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    outlist$header$STARTING_ANGLE <- as.numeric(stmp[jdx[2]])
  } else {
    outlist$header$STARTING_ANGLE <- NULL
  }

  # Starting frame
  idx <- grep("STARTING_FRAME",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx]," ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    outlist$header$STARTING_FRAME <- as.numeric(stmp[jdx[2]])
  } else {
    outlist$header$STARTING_FRAME <- NULL
  }

  # Resolution range
  idx <- grep("INCLUDE_RESOLUTION_RANGE",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx]," ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    outlist$header$INCLUDE_RESOLUTION_RANGE <- c(
      as.numeric(stmp[jdx[2]]),
      as.numeric(stmp[jdx[3]]))
  } else {
    outlist$header$INCLUDE_RESOLUTION_RANGE <- NULL
  }

  # Space group
  idx <- grep("SPACE_GROUP_NUMBER",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx]," ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    outlist$header$SPACE_GROUP_NUMBER <- as.integer(stmp[jdx[2]])
  } else {
    outlist$header$SPACE_GROUP_NUMBER <- NULL
  }

  # Unit cell
  idx <- grep("!UNIT_CELL_CONSTANTS",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx]," ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    ucell <- c()
    for (i in 2:length(jdx)) {
      ucell <- c(ucell,as.numeric(stmp[jdx[i]]))
    }
    outlist$header$UNIT_CELL_CONSTANTS <- ucell
  } else {
    outlist$header$UNIT_CELL_CONSTANTS <- NULL
  }

  # Unit cell A axis
  idx <- grep("!UNIT_CELL_A-AXIS",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx],"  ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    outlist$header$UNIT_CELL_AAXIS <- c(
      as.numeric(stmp[jdx[2]]),
      as.numeric(stmp[jdx[3]]),
      as.numeric(stmp[jdx[4]]))
  } else {
    outlist$header$UNIT_CELL_AAXIS <- NULL
  }

  # Unit cell B axis
  idx <- grep("!UNIT_CELL_B-AXIS",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx],"  ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    outlist$header$UNIT_CELL_BAXIS <- c(
      as.numeric(stmp[jdx[2]]),
      as.numeric(stmp[jdx[3]]),
      as.numeric(stmp[jdx[4]]))
  } else {
    outlist$header$UNIT_CELL_BAXIS <- NULL
  }

  # Unit cell C axis
  idx <- grep("!UNIT_CELL_C-AXIS",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx],"  ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    outlist$header$UNIT_CELL_CAXIS <- c(
      as.numeric(stmp[jdx[2]]),
      as.numeric(stmp[jdx[3]]),
      as.numeric(stmp[jdx[4]]))
  } else {
    outlist$header$UNIT_CELL_CAXIS <- NULL
  }

  # Reflecting range
  idx <- grep("!REFLECTING_RANGE_E.S.D.",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx],"  ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    outlist$header$REFLECTING_RANGE_E.S.D. <-
      as.numeric(stmp[jdx[2]])
  } else {
    outlist$header$REFLECTING_RANGE_E.S.D. <- NULL
  }

  # Beam divergence
  idx <- grep("!BEAM_DIVERGENCE_E.S.D.",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx],"  ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    outlist$header$BEAM_DIVERGENCE_E.S.D. <-
      as.numeric(stmp[jdx[2]])
  } else {
    outlist$header$BEAM_DIVERGENCE_E.S.D. <- NULL
  }

  # Wavelength
  idx <- grep("!X-RAY_WAVELENGTH",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx],"  ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    outlist$header$XRAY_WAVELENGTH <- as.numeric(stmp[jdx[2]])
  } else {
    outlist$header$XRAY_WAVELENGTH <- NULL
  }

  # Incident beam direction
  idx <- grep("!INCIDENT_BEAM_DIRECTION",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx]," ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    outlist$header$INCIDENT_BEAM_DIRECTION <- c(
      as.numeric(stmp[jdx[2]]),
      as.numeric(stmp[jdx[3]]),
      as.numeric(stmp[jdx[4]]))
  } else {
    outlist$header$INCIDENT_BEAM_DIRECTION <- NULL
  }

  # Fraction of polarization
  idx <- grep("!FRACTION_OF_POLARIZATION",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx]," ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    outlist$header$FRACTION_OF_POLARIZATION <- c(
      as.numeric(stmp[jdx[2]]))
  } else {
    outlist$header$FRACTION_OF_POLARIZATION <- NULL
  }

  # Polarization plane normal
  idx <- grep("!POLARIZATION_PLANE_NORMAL",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx]," ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    outlist$header$POLARIZATION_PLANE_NORMAL <- c(
      as.numeric(stmp[jdx[2]]),
      as.numeric(stmp[jdx[3]]),
      as.numeric(stmp[jdx[4]]))
  } else {
    outlist$header$POLARIZATION_PLANE_NORMAL <- NULL
  }

  # Air
  idx <- grep("!AIR",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx]," ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    outlist$header$AIR <- c(
      as.numeric(stmp[jdx[2]]))
  } else {
    outlist$header$AIR <- NULL
  }

  # Silicon
  idx <- grep("!SILICON",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx]," ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    outlist$header$SILICON <- c(
      as.numeric(stmp[jdx[2]]))
  } else {
    outlist$header$SILICON <- NULL
  }

  # Sensor thickness
  idx <- grep("!SENSOR_THICKNESS",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx]," ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    outlist$header$SENSOR_THICKNESS <- c(
      as.numeric(stmp[jdx[2]]))
  } else {
    outlist$header$SENSOR_THICKNESS <- NULL
  }

  # Type of detector
  idx <- grep("!DETECTOR=",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx],"=")
    stmp <- trimws(stmp[[1]][2],"both")
    outlist$header$DETECTOR <- stmp
  } else {
    outlist$header$DETECTOR <- NULL
  }

  # Overload
  idx <- grep("!OVERLOAD",lXDS)
  if (length(idx) == 1) {
    stmp <- strsplit(lXDS[idx]," ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    outlist$header$OVERLOAD <- c(
      as.numeric(stmp[jdx[2]]))
  } else {
    outlist$header$OVERLOAD <- NULL
  }

  # NX, NY, QX, QY
  idx <- grep("!NX",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx]," ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    outlist$header$NX_NY_QX_QY <- c(
      as.numeric(stmp[jdx[2]]),
      as.numeric(stmp[jdx[4]]),
      as.numeric(stmp[jdx[6]]),
      as.numeric(stmp[jdx[8]]))
  } else {
    outlist$header$NX_NY_QX_QY <- NULL
  }

  # ORGXX, ORGY
  idx <- grep("!ORGX",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx]," ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    outlist$header$ORGX_ORGY <- c(
      as.numeric(stmp[jdx[2]]),
      as.numeric(stmp[jdx[4]]))
  } else {
    outlist$header$ORGX_ORGY <- NULL
  }

  # Detector distance
  idx <- grep("!DETECTOR_DISTANCE",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx]," ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    outlist$header$DETECTOR_DISTANCE <- as.numeric(stmp[jdx[2]])
  } else {
    outlist$header$DETECTOR_DISTANCE <- NULL
  }

  # Direction of detector (X)
  idx <- grep("!DIRECTION_OF_DETECTOR_X-AXIS",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx]," ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    outlist$header$DIRECTION_OF_DETECTOR_XAXIS <- c(
      as.numeric(stmp[jdx[2]]),
      as.numeric(stmp[jdx[3]]),
      as.numeric(stmp[jdx[4]]))
  } else {
    outlist$header$DIRECTION_OF_DETECTOR_XAXIS <- NULL
  }

  # Direction of detector (Y)
  idx <- grep("DIRECTION_OF_DETECTOR_Y-AXIS",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx]," ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    outlist$header$DIRECTION_OF_DETECTOR_YAXIS <- c(
      as.numeric(stmp[jdx[2]]),
      as.numeric(stmp[jdx[3]]),
      as.numeric(stmp[jdx[4]]))
  } else {
    outlist$header$DIRECTION_OF_DETECTOR_YAXIS <- NULL
  }

  # Variance model
  idx <- grep("VARIANCE_MODEL",lXDS)
  if (length(idx) != 0) {
    stmp <- strsplit(lXDS[idx]," ")[[1]]
    jdx <- which(nchar(stmp) != 0)
    outlist$header$VARIANCE_MODEL <- c(
      as.numeric(stmp[jdx[2]]),
      as.numeric(stmp[jdx[3]]))
  } else {
    outlist$header$VARIANCE_MODEL <- NULL
  }

  ## Final: info on records
  idx <- grep("NUMBER_OF_ITEMS_IN_EACH_DATA_RECORD",lXDS)
  if (length(idx) == 1) {
    nrec <- as.integer(strsplit(lXDS[idx],"=")[[1]][2])
  }
  rtmp <- c()
  for (i in 1:nrec) {
    stmp <- strsplit(lXDS[idx+i],"=")[[1]][1]
    rec_name <- strsplit(stmp,"_")[[1]][2]
    rtmp <- c(rtmp,rec_name)
  }
  outlist$header$RECORD_NAMES <- rtmp

  return(outlist)
}



#' Load an XDS_ASCII file.
#'
#' Function to load XDS_ASCII.HKL files into a named list with
#' three components called \emph{processing_info}, \emph{header}
#' and \emph{reflections} (see details further down).
#'
#' This function reads in all data from an XDS_ASCII data file
#' and organises tham into a named list. The list's name are:
#' \describe{
#'   \item{processing_info}{This list component includes three
#'         logical variables, MERGE, FRIEDEL and PROFILE. Their
#'         TRUE/FALSE value reflect features of the XDS_ASCII
#'         file connected with the specific processing performed
#'         to obtain the file itself
#'         (for more details see \url{https://xds.mr.mpg.de/}).}
#'    \item{header}{This list includes several components, like
#'                  for instance SPACE_GROUP_NUMBER or
#'                  UNIT_CELL_CONSTANTS, which give informations
#'                  on the crystal and the experiment generating
#'                  the data.}
#'    \item{reflections}{This data.frame includes the actual
#'                      experimental data, i.e. the observations
#'                      collected during the X-ray diffraction
#'                      experiment on the crystal (or crystals).
#'                      The number and type of columns can vary.}
#' }
#'
#' @param filename A character string. The path to a valid
#'                 XDS ASCII file.
#' @param message A logical variable. If TRUE (default) the
#'                function prints a message highlighting what is
#'                included in the xds header.
#' @return A named list (see details).
#'
#' @examples
#'
#' # Load one of the XDS ASCII files included with
#' # this distribution of cry
#' datadir <- system.file("extdata",package="cry")
#' filename <- file.path(datadir,"xds_ascii_01.hkl")
#' ltmp <- readXDS_ASCII(filename,message=FALSE)
#' print(names(ltmp))
#' print(ltmp$reflections[1:5,])
#'
#' @export
readXDS_ASCII <- function(filename,message =FALSE) {
  # Read header first
  lXDS <- readXDS_ASCII_Header(filename)

  # Column names
  cnames <- lXDS$header$RECORD_NAMES

  # Read records from XDS_ASCII
  lXDS$reflections <- read.table(filename,
                    col.names=cnames,comment.char = "!")

  #ISIG <- xds$Iobs/xds$Sigma_Iobs
  #xds <- cbind(xds, ISIG)
  #if (ISIGMA != 1)
  #{
  #  xds <- xds[xds$ISIG <= ISIGMA, ]
  #}

  # Collect some statistics
  nrefs <- length(lXDS$reflections[,1])
  isigi <- lXDS$reflections$IOBS/lXDS$reflections$SIGMA.IOBS.
  msg <- c("\n")
  if (message) {
    msg <- c(msg,sprintf("File %s read successfully.\n",filename))
    msg2 <- sprintf("There are %d reflections in this file.\n",nrefs)
    msg <- c(msg,msg2)
    msg <- c(msg,"Here is a summary of the observations:\n")
    msg <- c(msg,"\n")
    cat(msg)
    print(summary(isigi))
  }

  return(lXDS)
}
